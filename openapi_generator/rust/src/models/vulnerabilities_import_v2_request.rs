/*
 * Vulnerability Management
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilitiesImportV2Request {
    /// The company that owns the product that is the source of the vulnerability data. To categorize the imported vulnerabilities in the same way that Tenable.io categorizes vulnerabilities detected in scans it manages, use the following values:   - tenable—A Nessus scan identified the vulnerabilities you want to import. Use this value for all Nessus scans, regardless of the scan manager (Tenable.io, Tenable.sc, or Nessus Manager).
    #[serde(rename = "vendor")]
    pub vendor: String,
    /// The name of the product from the vendor that is the source of the vulnerability data being imported.   - tenable.sc—The vulnerability data source is Tenable.sc.
    #[serde(rename = "product")]
    pub product: String,
    /// The type of scan that identified the vulnerabilities you want to import. To categorize the imported vulnerabilities in the same way that Tenable.io categorizes vulnerabilities detected in scans it manages, use the following values:   - vm—A Vulnerability Management scan identified the vulnerabilities.
    #[serde(rename = "data_type")]
    pub data_type: String,
    /// A unique string value used to track the set of assets and vulnerabilities that Tenable.io is importing and processing. For data imported from Tenable.sc via [Lumin synchronization](https://docs.tenable.com/security-center/Content/LuminSynchronization.htm), this value has the following format: scan_uuid:scan_chunk_uuid  where scan_uuid is the unique identifier for the scan in Tenable.sc (equivalent to the scan id used in [Tenable.sc API requests](https://docs.tenable.com/security-center/api/Scan.html)), and scan_chunk_uuid is the unique identifer that Tenable.sc assigns to individual chunks of scan data during the Lumin synchronization process.
    #[serde(rename = "source")]
    pub source: String,
    /// An array of asset objects with vulnerabilities information. A valid asset record requires at least one valid network_interface object.  **Note:** Tenable.io supports a maximum of 50 individual asset objects per request message. In addition, because Tenable.io supports a total size limit of 15 MB for the request message, you may want to limit the number of asset objects you include in an individual request, depending on the number of vulnerabilities identified on the assets and the size of the related vulnerability output.  **Note:** This endpoint does not support the network_id attribute in asset objects for import. Tenable.io automatically assigns imported assets to the default network object. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
    #[serde(rename = "assets")]
    pub assets: Vec<crate::models::VulnerabilitiesImportV2RequestAssetsInner>,
    #[serde(rename = "coverage", skip_serializing_if = "Option::is_none")]
    pub coverage: Option<Box<crate::models::VulnerabilitiesImportV2RequestCoverage>>,
}

impl VulnerabilitiesImportV2Request {
    pub fn new(vendor: String, product: String, data_type: String, source: String, assets: Vec<crate::models::VulnerabilitiesImportV2RequestAssetsInner>) -> VulnerabilitiesImportV2Request {
        VulnerabilitiesImportV2Request {
            vendor,
            product,
            data_type,
            source,
            assets,
            coverage: None,
        }
    }
}


